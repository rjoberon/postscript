%!PS-Adobe-2.0

% includes
% (sort.inc) run


% Koordinatensystem initialisieren
% Einheit: 1mm
% Überlegung: 72 Postscript-Punkte sind ein Zoll, ein Zoll sind 25,4 mm
2.8346456692 2.8346456692 scale
10 10 translate

% Standard-Linienbreite: 1/4 mm
/lw 0.25 def
lw setlinewidth

/debug {                % fname
    (\n) print
    (### ) print
    print
    ( ###) print
    (\n) print
    pstack
    (\n) print
} def

/debug1 {                % fname
    (\n) print
    (### ) print
    print
    ( ###) print
    (\n) print
    stack
    (\n) print
} def

/debug2 {
    (\n ########## HERE ##########\n) print
    pstack
    (\n ########## HERE ##########\n) print
} def

% draw a point at (x,y) as a circle with radius r
/draw-point {            % x y r
    3 1 roll             % r x y
    gsave
        translate        % r
        newpath
        0 0              % r 0 0
        3 -1 roll        % 0 0 r
        0 360            % 0 0 r 0 360
        arc
        stroke
    grestore
} def

% draw a point given as array [x y] at (x,y) as a circle with radius 5
/draw-point-a {          % [x y]
    aload                % x y [x y]
    pop                  % x y
    1                    % x y 5
    draw-point
} def

% draw an edge from (x1, y1) to (x2, y2)
/draw-edge {             % [[x1 y1] [x2 y2]]
    aload pop            % [x1 y1] [x2 y2]
    gsave
        2 1 roll         % [x2 y2] [x1 y1]
        aload pop        % [x2 y2] x1 y1
        moveto           % [x2 y2]
        aload pop        % x2 y2
        lineto           %
        stroke
    grestore
} def


% Funktionen für Datenstrukturen

%
% input: [a1 a2 ... an] [b1 b2 ... bm]
% output: [a1 a2 ... an b1 b2 .. bm]
%
/arr-concat {            % [a1 a2 ... an] [b1 b2 ... bm] → [a1 a2 ... an b1 b2 .. bm]
    exch                 % [b1 b2 ... bm] [a1 a2 ... an]
    2 copy               % [b1 b2 ... bm] [a1 a2 ... an] [b1 b2 ... bm] [a1 a2 ... an]
    length exch length   % [b1 b2 ... bm] [a1 a2 ... an] n m
    add array            % [b1 b2 ... bm] [a1 a2 ... an] [...]
    dup dup              % [b1 b2 ... bm] [a1 a2 ... an] [...] [...] [...]
    5 2 roll             % [...] [...] [b1 b2 ... bm] [a1 a2 ... an] [...]
    copy length exch     % [...] [...] [b1 b2 ... bm] n+m [a1 a2 ... an]
    putinterval          % [a1 a2 ... an b1 b2 .. bm]
} def

%
% input: [a1 a2 ... an]
% output: [a1 a2 ... ] an
%
/arr-pop {               % [a1 a2 ... an] → [a1 a2 ... ] an
    dup dup length       % [a1 a2 ... an] [a1 a2 ... an] n
    1 sub dup            % [a1 a2 ... an] [a1 a2 ... an] n-1 n-1
    3 1 roll             % [a1 a2 ... an] n-1 [a1 a2 ... an] n-1
    get                  % [a1 a2 ... an] n-1 an
    3 1 roll             % an [a1 a2 ... an] n-1
    0 exch               % an [a1 a2 ... an] 0 n-1
    getinterval          % an [a1 a2 ... ]
    exch                 % [a1 a2 ... ] an
} def

% Datenstrukturen:
% - points → stack
% - edges → list
% - circle_events → priority queue (stets sortiert)

% Circle Event
%
% Constructor.
%
% input: x point arc
% output: cevent
%
/circle-event-new {      % x point arc
    [ 4 1 roll true ]
    % [x point arc is_valid]
} def
% Getter for circle event. Input: cevent
/circle-event-get-x     {0 get} def
/circle-event-get-point {1 get} def
/circle-event-get-arc   {2 get} def
/circle-event-is-valid  {3 get} def
% Setter for circle event. Input: cevent value
/circle-event-set-x     {0 exch put} def
/circle-event-set-point {1 exch put} def
/circle-event-set-arc   {2 exch put} def
/circle-event-set-valid {3 exch put} def


% Parabola Arc
%
% Contructor.
%
% input: point arc1 arc2
% output: parabolaarc
%
/parabola-arc-new {      % point arc1 arc2
    [ 4 1 roll null null null ]
    % [point previous_arc next_arc circle_event edge1 edge2]
} def
% Getter for parabola arc. Input: parabolaarc
/parabola-arc-get-point    {(pag-point) debug1 0 get} def
/parabola-arc-get-previous {(pag-previous) debug1 1 get} def
/parabola-arc-get-next     {(pag-next) debug1 2 get} def
/parabola-arc-get-cevent   {(pag-cevent) debug1 3 get} def
/parabola-arc-get-edge1    {4 get} def
/parabola-arc-get-edge2    {5 get} def
% Setter for parabola arc. Input: parabolaarc value
/parabola-arc-set-previous {1 exch put} def
/parabola-arc-set-next     {2 exch put} def
/parabola-arc-set-cevent   {3 exch put} def
/parabola-arc-set-edge1    {4 exch put} def
/parabola-arc-set-edge2    {5 exch put} def

% Voronoi Edge
%
% Constructor.
%
% input: point
% output: vedge
/voronoi-edge-new {      % point
    [ exch [0 0] false ]
    % [point1 point2 is_finished]
    % FIXME: add to edges
} def
% Getter for voronoi edge. Input: vedge
/voronoi-edge-is_finished {2 get} def
% Setter for voronoi edge. Input: vedge value
/voronoi-edge-set-point1   {0 exch put} def
/voronoi-edge-set-point2   {1 exch put} def
/voronoi-edge-set-finished {2 exch put} def
/voronoi-edge-finish {   % vedge point
    exch dup             % point vedge vedge
    voronoi-edge-is-finished
    not                  % point vedge !is_finished
    {                    % point vedge
        dup              % point vedge vedge
        3 -1 roll        % vedge vedge point
        voronoi-edge-set-point2
        true voronoi-edge-set-finished
    } if
} def

% Circle Events
%
/circle-events-append {  % cevents cevent
    ( IMPLEMENT:append ) print
    % FIXME: implement
    quit
} def
/circle-events-sort {    % cevents
    ( IMPLEMENT:sort ) print
    % FIXME: implement
    quit
} def

% Root
%
/root [ null ] def
/root-get {root 0 get} def
/root-set {root 0 3 -1 roll put} def

%
% input: [[pnx pny] ... [p1x p1y]]
%        = a sorted array of points
% output: [[[x1 y1] [x2 y2]] ... [[x1 y1] [x2 y2]]]
%        = an array of edges
%
/fortune {               % points x1 y1 x2 y2
    5 dict begin
    % process arguments
    /y2 exch def
    /x2 exch def
    /y1 exch def
    /x1 exch def

    % organise stack
    mark exch            % *
    aload pop            % * points
    []                   % * points [edges]
    []                   % * points [edges] [cevents]

    pstack
    % loop over points
    {
        ( loop ) print
        % while len(fortune.points) > 0:
        counttomark      % 2 + len(fortune.points)
        2 sub            % len(fortune.points)
        0 le { exit } if % <= 0 → exit loop
        % if ...
        dup length       % len(fortune.circle_events)
        0 gt             % |cevents| > 0
        { % len(fortune.circle_events) > 0
            dup 0 get    % cevents[0]
            circle-event-get-x
            3 index 0 get% cevents[0].x [px py]
            0 get le     % cevents[0].x <= px
            { % fortune.circle_events[0].x <= fortune.points[0].x
                process-circle-event
            } {
                ( pp1 ) print
                x1 process-point
            } ifelse
        } {
            ( pp2 ) print
            x1 process-point
        } ifelse

    } loop

    % after all points are processed, finish remaining circle events
    % FIXME: TODO
    end
} def

%
% Process the remaining leftmost point (right of the sweep line).
%
% input: pn ... p0 [edges] [circle_events] x
% no output
%
/process-point {         % pn ... p1 p0 [edges] [circle_events] x
    4 -1 roll            % pn ... p1 [edges] [circle_events] x p0
    exch                 % pn ... p1 [edges] [circle_events] p0 x
    add-new-arc          % pn ... p1 [edges] [circle_events]
} def

%
% Process circle event with the smallest x coordinate.
%
% input: pn ... p0 [edges] [circle_events]
% output:
%
/process-circle-event {
    ( process-circle-event ) debug
    3 dict begin
    % process arguments
    arr-pop              % cevent
    /cevent exch def

    cevent circle-event-is-valid
    {
        % edge = VoronoiEdge(circle_event.point) # new edge
        cevent circle-event-get-point
        voronoi-edge-new
        /edge exch def
        % arc = circle_event.arc
        /arc cevent circle-event-get-arc def

        % delete corresponding parabola arc
        arc parabola-arc-get-previous null ne
        {
            % arc.previous_arc.next_arc = arc.next_arc
            arc parabola-arc-get-previous
            arc parabola-arc-get-next parabola-arc-set-next
            % arc.previous_arc.edge2 = edge
            arc parabola-arc-get-previous
            edge parabola-arc-set-edge2
        } if
        arc parabola-arc-get-next null ne
        {
            % arc.next_arc.previous_arc = arc.previous_arc
            arc parabola-arc-get-next
            arc parabola-arc-get-previous parabola-arc-set-previous
            % arc.next_arc.edge1 = edge
            arc parabola-arc-get-next
            edge parabola-arc-set-edge1
        } if

        % finish adjacent edges of the parabola arc
        arc parabola-arc-get-edge1 null ne
        {
            % arc.edge1.finish(circle_event.point)
            arc parabola-arc-get-edge1
            cevent circle-event-get-point
            voronoi-edge-finish
        } if
        arc parabola-arc-get-edge2 null ne
        {
            % arc.edge2.finish(circle_event.point)
            arc parabola-arc-get-edge2
            cevent circle-event-get-point
            voronoi-edge-finish
        } if

        % check circle vents on both sides of the parabola arc
        arc parabola-arc-get-previous null ne
        {
            % self.check_circle_event(arc.previous_arc, circle_event.x)
            arc parabola-arc-get-previous
            cevent circle-event-get-x
            check-circle-event
        } if
        arc parabola-arc-get-previous null ne
        {
            % self.check_circle_event(arc.next_arc, circle_event.x)
            arc parabola-arc-get-next
            cevent circle-event-get-x
            check-circle-event
        } if

    } if
    end
} def

%
% Add a new arc.
%
% input: [px py] x
% no output
%
/add-new-arc {           % [px py] x
    ( add-new-arc ) debug
    5 dict begin
    % process arguments
    /x exch def          % [px py]
    aload pop            % px py
    /py exch def         % px
    /px exch def         %

    root-get null eq {
        [px py]          % [px py]
        null null        % [px py] null null
        parabola-arc-new % pa
        root-set         % /root → pa
    } {
        % determine the current parabola arc with the coordinate of point
        /arc root-get def
        % while arc is not None:
        {
            (\nLOOP START\n) print

            arc null eq {% exit when arc is null
                exit
            } if
            % check for intersection
            [px py] arc get-intersection
            {            % [i1x i1y]
                % if arc.next_arc is not None and
                %    not self.get_intersection(point, arc.next_arc):
                arc parabola-arc-get-next
                (\n##### next #####\n) print
                null ne  % [i1x i1y] !=
                dup      % [i1x i1y] != !=
                {
                    [px py]  % [i1x i1y] != [px py]
                    arc parabola-arc-get-next
                    get-intersection
                    not  % [i1x i1y] != [i2x i2y] !=
                    exch % [i1x i1y] != != [i2x i2y]
                    pop  % [i1x i1y] != !=
                } {
                    false% [i1x i1y] != false
                } ifelse
                and      % [i1x i1y] != and !=
                {
                    arc parabola-arc-get-next
                    % build new parabola arc ...
                    arc parabola-arc-get-point
                    arc
                    arc parabola-arc-get-next
                    parabola-arc-new
                    dup  % copy second assignment
                    % arc.next_arc.previous_arc = ...
                    parabola-arc-set-previous
                    % arc.next_arc = ...
                    arc exch parabola-arc-set-next
                } {
                    arc
                    % build new parabola arc ...
                    arc parabola-arc-get-point
                    arc
                    null
                    parabola-arc-new
                    % arc.next_arc = ...
                    parabola-arc-set-next
                } ifelse % [i1x i1y]
                % arc.next_arc.edge2 = arc.edge2
                arc parabola-arc-get-next
                arc parabola-arc-get-edge2
                parabola-arc-set-edge2

                % insert new parabola arc between arc and arc.next_arc
                % arc.next_arc.previous_arc = ParabolaArc(point, arc, arc.next_arc)
                % FIXME: hier weiter bei .next() ist Stack defekt
                arc parabola-arc-get-next
                [px py] arc arc parabola-arc-get-next
                parabola-arc-new
                parabola-arc-set-previous
                % arc.next_arc = arc.next_arc.previous_arc
                arc
                arc parabola-arc-get-next
                parabola-arc-get-previous
                parabola-arc-set-next
                % arc = arc.next_arc
                /arc arc parabola-arc-get-next def
                % FIXME: debug
                arc 0 get% [px py]
                aload pop% px py
                exch     % py px
                (\nARC px = ) print (        ) cvs print
                (\nARC py = ) print (        ) cvs print (\n) print

                % connect two new edges with the endpoints of the parabola arc
                % arc.edge1 = VoronoiEdge(intersection1)
                dup      % [i1x i1y] [i1x i1y]
                voronoi-edge-new dup
                arc exch % [i1x i1y] vedge arc vedge
                parabola-arc-set-edge1
                % arc.previous_arc.edge2 = arc.edge1
                arc parabola-arc-get-previous
                exch     % [i1x i1y] arc vedge
                parabola-arc-set-edge2
                % arc.edge2 = VoronoiEdge(intersection1)
                voronoi-edge-new dup
                arc exch % vedge arc vedge
                parabola-arc-set-edge2
                % arc.next_arc.edge1 = arc.edge2
                arc parabola-arc-get-next
                exch     % arc vedge
                parabola-arc-set-edge1


                % check neighboring circle events of the parabola arc
                arc                           px check-circle-event
                arc parabola-arc-get-previous px check-circle-event
                arc parabola-arc-get-next     px check-circle-event
                exit % return % FIXME: hier wirklich RETURN und nicht nach loop weiter!
            } if
            /arc arc parabola-arc-get-next def
        } loop

        % special case: if the parabola arc does not intersect with
        % another arc it will be added to the doubly linked list
        /arc root-get def
        {
            % determine last parabola arc
            arc parabola-arc-get-next
            null eq {
                exit
            } if
            /arc arc parabola-arc-get-next def
        } loop
        % arc.next_arc = ParabolaArc(point, arc, None)
        arc
        point arc null parabola-arc-new
        parabola-arc-set-next
        % add edge between parabola arcs
        [
            x
            arc parabola-arc-get-next parabola-arc-get-point 1 get
            arc parabola-arc-get-point 1 get
            add
            2 div        % (arc.next_arc.point.y + arc.point.y) / 2)
        ] voronoi-edge-new
        % arc.next_arc.edge1 = VoronoiEdge(...)
        dup              % vedge vedge
        arc parabola-arc-get-next
        exch             % vedge arc vedge
        parabola-arc-set-edge1
        arc exch         % arc vedge
        parabola-arc-set-edge2
    } ifelse
    end
} def

%
% If necessary, create a new circle event for the given parabola arc.
%
% input: arc x
% no output
%
/check-circle-event {    % arc x
    ( check-circle-event ) debug1
    3 dict begin
    % process arguments
    /x exch def
    /arc exch def

    % invalidate current circle event
    % if arc.circle_event is not None and arc.circle_event.x != _x:
    arc parabola-arc-get-cevent dup
    null ne              % cevent !=
    {
        circle-event-get-x
        x ne
        {
            % arc.circle_event.is_valid = False
            arc parabola-arc-get-cevent
            false circle-event-set-valid
        } if
    } if
    % arc.circle_event = None
    arc null parabola-arc-set-cevent
    % if arc.previous_arc is None or arc.next_arc is None:
    arc parabola-arc-get-previous
    null ne
    arc parabola-arc-get-next
    null ne
    and
    {
        arc parabola-arc-get-previous parabola-arc-get-point
        arc parabola-arc-get-point
        arc parabola-arc-get-next parabola-arc-get-point
        get-rightmost-circle-point
        {                % [px py] x
            dup x        % [px py] x x _x
            gt           % [px py] x x > _x
            pstack
            {            % [px py] x
                exch arc % x [px py] arc
                circle-event-new
                dup      % cevent cevent
                arc exch % cevent arc cevent
                parabola-arc-set-cevent
                         % cevent
                % FIXME: add args for next two calls (if necessary)
                circle-events-append
                circle-events-sort
            } if
        } if
    } if
    end
} def

% Given three points, check whether they are all on one line. If not,
% determine the x coordinate of the circle through all three points.
%
% input:
%   [p1x p1y] [p2x p2y] [p3x p3y]
% output:
%   false
%   [px py] x true
%
/get-rightmost-circle-point { % [p1x p1y] [p2x p2y] [p3x p3y]
    ( get-rightmost-circle-point ) debug
    12 dict begin
    % process arguments
    aload pop /p3y exch def /p3x exch def
    aload pop /p2y exch def /p2x exch def
    aload pop /p1y exch def /p1x exch def

    % check that the three points are oriented clockwise
    p2x p1x sub               % p2x - p1x
    p3y p1y sub               % p2x - p1x p3y - p1y
    mul                       % (p2x - p1x) * (p3y - p1y(
    p3x p1x sub               % p3x - p1x
    p2y p1y sub               % p3x - p1x p2y - p1y
    mul                       % (p3x - p1x) * (p2y - p1y)
    gt
    { false }{                % leave with false on stack
        p2x p1x sub
        /x1 exch def
        p2y p1y sub
        /y1 exch def
        x1                    % x1
        p3y p2y sub           % x1 p3y - p2y
        mul                   % x1 * (p3y - p2y)
        y1                    % x1 * (p3y - p2y) y1
        p3x p2x sub           % x1 * (p3y - p2y) y1 p3x - p2x
        mul                   % x1 * (p3y - p2y) y1 * (p3x - p2x)
        sub                   % x1 * (p3y - p2y) - y1 * (p3x - p2x)
        2 mul                 % (x1 * (p3y - p2y) - y1 * (p3x - p2x)) * 2
        /a exch def
        % all three points on a line?
        a 0 eq
        { false }{            % leave with false on stack
            p3x p1x sub
            /x2 exch def
            p3y p1y sub
            /y2 exch def
            x1                % x1
            p1x p2x add       % x1 p1x - p2x
            mul               % x1 * (p1x + p2x)
            y1                % x1 * (p1x + p2x) y1
            p1y p2y add       % x1 * (p1x + p2x) y1 p1y + p2y
            mul               % x1 * (p1x + p2x) y1 * (p1y + p2y)
            add               % x1 * (p1x + p2x) + y1 * (p1y + p2y)
            /a1 exch def
            x2                % x2
            p1x p3x add       % x2 p1x - p3x
            mul               % x2 * (p1x + p3x)
            y2                % x2 * (p1x + p3x) y2
            p1y p3y add       % x2 * (p1x + p3x) y2 p1y + p3y
            mul               % x2 * (p1x + p3x) y2 * (p1y + p3y)
            add               % x2 * (p1x + p3x) + y2 * (p1y + p3y)
            /a2 exch def
            % center of circle through three the points
            y2 a1 mul
            y1 a2 mul
            sub a div         % (y2 * a1 - y1 * a2) / a
            /px exch def
            x1 a2 mul
            x2 a1 mul
            sub a div         % (x1 * a2 - x2 * a1) / a
            /py exch def
            % x coordinate of center plus radius
            p1x px sub        % p1x - px
            dup mul           % (p1x - px)²
            p1y py sub        % (p1x - px)² p1y - py
            dup mul           % (p1x - px)² (p1y - py)²
            add               % (p1x - px)² + (p1y - py)²
            sqrt              % sqrt((p1x - px)² + (p1y - py)²)
            px add            % sqrt((p1x - px)² + (p1y - py)²) + px → x
            [px py] exch      % [px py] x
            true              % [px py] x true
        } ifelse
    } ifelse
    end
} def


%
% Compute intersection between parabola with given focal point and
% parabola arc, if it exists.
%
% input: point arc
% output:
%   false
%   [ix iy] true
%
/get-intersection {      % [px py] arc
    ( get-intersection ) debug1
    5 dict begin
    % process arguments
    /arc exch def        % [px py]
    aload pop            % px py
    /py exch def
    /px exch def

    % if arc.point.x == point.x:
    arc parabola-arc-get-point
    aload pop
    pop px eq {
        false            % focal points match → return false
    } {
        % if arc.previous_arc is not None:
        arc parabola-arc-get-previous
        dup              % pa pa
        null ne {        % pa !=
            % compute y coordinate of the intersection between the
            % current and the previous parabola arc
            parabola-arc-get-point
            arc parabola-arc-get-point
            px           % [p1x p1y] [p2x p2y] x
            get-parabolas-intersection
                         % [ix iy]
            aload pop    % ix iy
            /y1 exch def % ix
            pop
        } {
            pop          % remove pa
        } ifelse
        % if arc.next_arc is not None:
        arc parabola-arc-get-next
        dup              % pa pa
        null ne {        % pa !=
            % compute y coordinate of the intersection between the
            % current and the next parabola arc
            parabola-arc-get-point
            arc parabola-arc-get-point
            exch
            px           % [p1x p1y] [p2x p2y] x
            get-parabolas-intersection
                         % [ix iy]
            aload pop    % ix iy
            /y2 exch def % ix
            pop
        } {
            pop          % remove pa
        } ifelse

        % compute coordinate of the intersection, if it exists
        % if (arc.previous_arc is None or y1 <= point.y) and (arc.next_arc is None or point.y <= y2):
        arc parabola-arc-get-previous
        null eq
        y1 py le
        or               % arc.previous_arc is None or y1 <= point.y
        arc parabola-arc-get-next
        null eq
        py y2 le
        or               % arc.next_arc is None or point.y <= y2
        and
        {
            [
                py       % iy
                arc parabola-arc-get-point
                aload pop% iy apx apy
                exch     % iy apy apx
                debug2   % FIXME: Werte stimmen, aber Ergebnis nicht → Rechnung prüfen
                dup      % iy apy apx apx
                dup mul  % iy apy apx apx²
                3 -1 roll% iy apx apx² apy
                py sub   % iy apx apx² apy-iy
                dup mul  % iy apx apx² (apy-iy)²
                px       % iy apx apx² (apy-iy)² px
                dup mul  % iy apx apx² (apy-iy)² px²
                sub add  % iy apx apx² + (apy-iy)² - px²
                exch     % iy apx² + (apy-iy)² - px² apx
                px sub   % iy apx² + (apy-iy)² - px² apx-px
                2 mul    % iy apx² + (apy-iy)² - px² 2*(apx-px)
                div      % iy (apx² + (apy-iy)² - px²) / (2*(apx-px))
                exch     % ix iy
            ]
            true         % return [ix iy] true
        }{
            false        % return false
        } ifelse
    } ifelse

    end
} def

%
% Determine the intersection of two parabolas with the given focal
% points for a sweep line with the given x coordinate.
%
% input: [p1x p1y] [p2x p2y] x
% output: [ix iy]
%
/get-parabolas-intersection { % [p1x p1y] [p2x p2y] x
    ( get-parabolas-intersection ) debug
    13 dict begin
    % process arguments
    /x exch def
    aload pop /p2y exch def /p2x exch def
    aload pop /p1y exch def /p1x exch def

    p1x p1y                   % point
    p1x p2x eq
    { % special cases
        p1y p2y add 2 div     % (p1y + p2y) / 2 → iy'
    }{
        p2x x eq
        {
            p2y               % → iy'
        }{
            p1x x eq
            {
                pop pop       %
                p2x p2y       % p2x p2y
                p1y           % → iy'
            }{ % default case
                % compute y coordinate of the intersection using
                % solution for quadratic equations
                p1x x sub     % p1x - x
                2 mul         % (p1x - x) * 2
                /x1 exch def
                p2x x sub     % p2x - x
                2 mul         % (p2x - x) * 2
                /x2 exch def
                1 x1 div
                1 x2 div
                sub           % 1/x1 - 1/x2
                /a exch def
                p1y x1 div
                p2y x2 div
                sub
                -2 mul        % -2 * (p1y/x1 - p2y/x2)
                /b exch def
                p1y dup mul
                p1x dup mul
                x dup mul
                sub
                add
                x1 div         % (p1y² + p1x² - x²) / x1
                p2y dup mul
                p2x dup mul
                x dup mul
                sub
                add
                x2 div         % (p2y² + p2x² - x²) / x2
                sub
                /c exch def
                b neg
                b dup mul
                4 a c mul mul
                sub
                sqrt
                sub
                2 a mul
                div            % (-b - sqrt(b * b - 4 * a * c)) / (2 * a)
            } ifelse
        } ifelse
    } ifelse
    % result of all ifelse: iy on top of stack
    % now on stack:         px py iy
    /iy exch def            % FIXME: those three defs can be removed
    /py exch def
    /px exch def

    % insert y coordinate into equation for parabola to get x coordinate
    px dup mul
    py iy sub dup mul
    x dup mul
    sub add               % px² + (py - iy)² - x²
    2 px x sub mul
    div                   % (px² + (py - iy)² - x²) / (2 * (px - x))
    [ exch iy ]
    end
} def

%
% Finish adjacent edges of parabola arcs
%
% input: x1 y1 x2 y2
% no output
%
/finish-edges {           % x1 y1 x2 y2
    ( finish-edges ) debug
    1 dict begin
    % move sweep line such that no parabola cuts through the drawing plane
    3 -1 roll            % x1 x2 y2 y1
    sub                  % x1 x2 y2-y1
    3 -2 roll            % y2-y1 x1 x2
    dup                  % y2-y1 x1 x2 x2
    3 -1 roll            % y2-y1 x2 x2 x1
    sub                  % y2-y1 x2 x2-x1
    add add              % (y2-y1) + x2 + (x2-x1) → x

    % extend each new edge to the intersection with the new parabola
    /arc root-get def
    {
        arc parabola-arc-get-next
        null eq
        {
            exit
        } if
        arc parabola-arc-get-edge2
        null ne
        {
            % self.get_parabolas_intersection(arc.point, arc.next_arc.point, 2 * x)
            arc parabola-arc-get-point
            arc parabola-arc-get-next parabola-arc-get-point
            3 -1 roll
            2 mul
            get-parabolas-intersection
            % arc.edge2.finish
            arc parabola-arc-get-edge2
            exch
            voronoi-edge-finish
        } if
        /arc arc parabola-arc-get-next def
    } loop
    end
} def




% Punkte
/points
[
%    [40.958 77.998]
%    [39.257 23.810]
%    [38.560 52.197]
%    [29.689 27.931]
%    [20.042 67.723]
%    [19.844 4.945]
%    [18.093 10.194]
%    [17.828 14.802]
    [13.757 63.445]
    [12.985 40.466]
]
def




% Kanten
/edges
[
    [[-328.620 63.445] [23.347 51.620]]
    [[-328.620 63.445] [-827074.763 27838.719]]
    [[-52.593 14.802] [-101.080 5.652]]
    [[-52.593 14.802] [16.577 27.855]]
    [[-22.103 10.194] [-101.080 5.652]]
    [[-22.103 10.194] [31.087 13.253]]
    [[-101.080 5.652] [-32840.501 -5518.693]]
    [[11.101 4.945] [-8491.394 -2831.380]]
    [[11.101 4.945] [31.956 11.902]]
    [[15.444 67.723] [24.569 54.316]]
    [[15.444 67.723] [-578.961 940.989]]
    [[16.634 27.931] [16.577 27.855]]
    [[16.634 27.931] [27.544 42.470]]
    [[16.577 27.855] [30.075 15.660]]
    [[23.608 52.197] [23.347 51.620]]
    [[23.608 52.197] [24.569 54.316]]
    [[23.347 51.620] [27.544 42.470]]
    [[24.569 54.316] [34.053 65.628]]
    [[33.586 23.810] [30.075 15.660]]
    [[33.586 23.810] [39.707 38.023]]
    [[27.976 77.998] [34.053 65.628]]
    [[27.976 77.998] [-323.933 794.352]]
    [[27.544 42.470] [39.707 38.023]]
    [[30.075 15.660] [31.087 13.253]]
    [[31.087 13.253] [31.956 11.902]]
    [[31.956 11.902] [214.406 -175.848]]
    [[34.053 65.628] [270.177 43.682]]
    [[39.707 38.023] [270.177 43.682]]
    [[270.177 43.682] [259.165 44.028]]
]
def

%1 0 0 setrgbcolor
% edges {draw-edge} forall

% TODO: points.sort()
% draw points
%points {draw-point-a} forall
% fortune = Fortune(points)
points 0 0 800 800 fortune

( DONE ) print
% pstack


% showpage
